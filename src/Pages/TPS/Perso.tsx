/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.1.3 -k public/perso.gltf perso
*/

import { useGLTF, useKeyboardControls, useTexture } from "@react-three/drei"
import { useFrame, useThree } from "@react-three/fiber"
import { BallCollider, RapierRigidBody, RigidBody } from "@react-three/rapier"
import { useControls } from "leva"
import {
  Suspense,
  forwardRef,
  useEffect,
  useImperativeHandle,
  useMemo,
  useRef,
} from "react"
import { Group, MathUtils, Mesh, Quaternion, Raycaster, Vector3 } from "three"
import { useDisableSpacebar } from "../../utils/useDisableSpacebar"
import { Controls } from "./Tps"

const CorpsMaterial = () => {
  const image = useTexture("/robot-corps.webp")
  return (
    <Suspense fallback={<meshBasicMaterial color={0xf07b00} />}>
      <meshBasicMaterial map={image} />
    </Suspense>
  )
}
const TeteMaterial = () => {
  const image = useTexture("/robot-tete.webp")
  image.flipY = false
  return (
    <Suspense fallback={<meshBasicMaterial color={0xf07b00} />}>
      <meshBasicMaterial map={image} />
    </Suspense>
  )
}

export const Perso = forwardRef(function Perso(props: any, ref) {
  const sphereBody = useRef<RapierRigidBody>(null)
  useDisableSpacebar()

  const direction = useRef(new Vector3())
  const frontVector = useRef(new Vector3())
  const sideVector = useRef(new Vector3())
  const SPEED = useRef(4)
  const RUN_SPEED = useRef(8)
  const { nodes, materials } = useGLTF("/robot.glb") as any
  const { offset } = useControls({ offset: { x: 0, y: 1.4, z: 2 } })
  const { lookAt } = useControls({ lookAt: { x: 0, y: 1.2, z: 0 } })
  const forwardPressed = useKeyboardControls<Controls>((state) => state.forward)
  const backPressed = useKeyboardControls<Controls>((state) => state.back)
  const leftPressed = useKeyboardControls<Controls>((state) => state.left)
  const rightPressed = useKeyboardControls<Controls>((state) => state.right)
  const runPressed = useKeyboardControls<Controls>((state) => state.run)
  const jumpPressed = useKeyboardControls<Controls>((state) => state.jump)
  const characterRef = useRef<Group>(null!)
  const characterCorpsRef = useRef<Mesh>(null!)
  const persoRef = useRef<Group>(null!)
  const camera = useThree((state) => state.camera)
  const domElement = useThree((state) => state.gl.domElement)
  const shouldLerp = useRef(false)
  const rotation = useRef(0)
  const lastHiddenObject = useRef<Map<string, any>>(new Map())
  useEffect(() => {
    camera.layers.set(0)
  }, [])
  useEffect(() => {
    if (characterRef.current) {
      rotation.current = characterRef.current.rotation.y
    }
  }, [characterRef.current])
  useEffect(() => {
    function lock() {
      domElement.requestPointerLock()
    }

    function unlock() {
      if (document.pointerLockElement === domElement) {
        document.exitPointerLock()
      }
    }

    const handleEscape = (event: KeyboardEvent) => {
      if (event.key === "j") {
        unlock()
      }
    }

    domElement.addEventListener("click", lock)
    document.addEventListener("keydown", handleEscape)
    return () => {
      domElement.removeEventListener("click", lock)
      document.removeEventListener("keydown", handleEscape)
    }
  }, [domElement])
  useEffect(() => {
    function onMouseMove(event: any) {
      const movementX =
        event.movementX || event.mozMovementX || event.webkitMovementX || 0
      const movementY =
        event.movementY || event.mozMovementY || event.webkitMovementY || 0
      rotation.current -= movementX * 0.001
    }
    document.addEventListener("pointerlockchange", lockChangeAlert, false)
    function lockChangeAlert() {
      if (document.pointerLockElement === domElement) {
        domElement.addEventListener("mousemove", onMouseMove, false)
      } else {
        domElement.removeEventListener("mousemove", onMouseMove, false)
      }
    }
  }, [domElement])
  let lerpTime = 0
  useFrame((state, delta) => {
    frontVector.current.set(0, 0, Number(backPressed) - Number(forwardPressed))
    sideVector.current.set(Number(leftPressed) - Number(rightPressed), 0, 0)
    direction.current
      .subVectors(frontVector.current, sideVector.current)
      .normalize()
      .multiplyScalar(runPressed ? RUN_SPEED.current : SPEED.current)
      .applyEuler(characterRef.current.rotation)
    const currentLinvel = sphereBody.current!.linvel()
    sphereBody.current?.setLinvel(
      { x: direction.current.x, y: currentLinvel.y, z: direction.current.z },
      true
    )
    if (jumpPressed && Math.abs((currentLinvel.y as any).toFixed(2)) < 0.05) {
      sphereBody.current?.setLinvel(
        { x: currentLinvel.x, y: 5, z: currentLinvel.z },
        true
      )
    }
    const position = sphereBody.current!.translation()
    characterRef.current.position.copy(
      new Vector3(position.x, position.y - 0.5, position.z)
    )
    const rotationFromRapier = sphereBody.current!.rotation()
    characterCorpsRef.current.position.copy(
      new Vector3(position.x, position.y, position.z)
    )
    characterCorpsRef.current.setRotationFromQuaternion(
      new Quaternion(
        rotationFromRapier.x,
        rotationFromRapier.y,
        rotationFromRapier.z,
        rotationFromRapier.w
      )
    )
    characterRef.current.rotation.y = MathUtils.lerp(
      characterRef.current.rotation.y,
      rotation.current,
      0.15
    )
    const look = new Vector3(lookAt.x, lookAt.y, lookAt.z)
    look.add(characterRef.current!.position)

    const off = new Vector3(offset.x, offset.y, offset.z)
    off.applyQuaternion(characterRef.current!.quaternion)
    off.add(characterRef.current!.position)

    if (shouldLerp.current) {
      const t = 1.0 - Math.pow(0.001, delta)
      camera.position.lerp(off, t)
      lerpTime += delta
      if (lerpTime >= 0.6) {
        shouldLerp.current = false
        lerpTime = 0
      }
    } else {
      camera.position.copy(off)
    }
    camera.lookAt(look)
    camera.updateProjectionMatrix()

    // lastHiddenObject.current.forEach((object) => object.layers.set(0))
    // raycaster.set(
    //   camera.position,
    //   persoRef.current.position.clone().sub(camera.position).normalize()
    // )
    // const intersects = raycaster.intersectObjects(scene.children, true)
    // lastHiddenObject.current.clear()
    // intersects.forEach((intersect) => {
    //   // if(intersect.object.name === "corps"){
    //   //   console.log(intersect.distance)
    //   // }
    //   if (
    //     intersect.distance < 2 &&
    //     ![
    //       "corps",
    //       "bv_collider006",
    //       "bv_collider009",
    //       "bv_collider010",
    //       "bv_collider011",
    //       "bv_collider012",
    //       "bv_collider013",
    //       "Cube088_1",
    //       "Cube088_2",
    //     ].includes(intersect.object.name)
    //   ) {
    //     lastHiddenObject.current.set(intersect.object.name, intersect.object)
    //     intersect.object.layers.set(1)
    //   }
    // })
  })

  useImperativeHandle(
    ref,
    () => {
      return {
        getPersoPosition() {
          return characterRef.current.position
        },
      }
    },
    [characterRef]
  )

  return (
    <group ref={persoRef}>
      <RigidBody
        colliders={false}
        ref={sphereBody}
        position={[0, 1, 0]}
        mass={70}
      >
        <BallCollider args={[0.5]} />
      </RigidBody>
      <mesh
        ref={characterCorpsRef}
        name="corps"
        geometry={nodes.corps.geometry}
      >
        <CorpsMaterial />
      </mesh>
      <group ref={characterRef} {...props} dispose={null}>
        <group rotation={[0, Math.PI / 2, 0]}>
          <mesh
            name="oeuil_g"
            geometry={nodes.oeuil_g.geometry}
            material={materials["Material.004"]}
            position={[0.25, 1.17, -0.06]}
            rotation={[0, 0.17, -1.27]}
          />
          <mesh
            name="antenne1"
            geometry={nodes.antenne1.geometry}
            material={nodes.antenne1.material}
            position={[-0.05, 1.25, 0.06]}
          />
          <mesh
            name="tete"
            geometry={nodes.tete.geometry}
            position={[0, 1.09, 0]}
          >
            <TeteMaterial />
          </mesh>
          <group
            name="antenne2"
            position={[-0.11, 1.23, -0.06]}
            rotation={[0, 0, -0.07]}
          >
            <mesh
              name="Cilindro001"
              geometry={nodes.Cilindro001.geometry}
              material={materials["Material.007"]}
            />
            <mesh
              name="Cilindro001_1"
              geometry={nodes.Cilindro001_1.geometry}
              material={materials["Material.008"]}
            />
          </group>
          <mesh
            name="oeuil_d"
            geometry={nodes.oeuil_d.geometry}
            material={materials["Material.004"]}
            position={[0.24, 1.17, 0.08]}
            rotation={[0, -0.26, -1.27]}
          />
        </group>
      </group>
    </group>
  )
})

useGLTF.preload("/robot.glb")
